{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\"a whole log simpler\" ... literally! What does this package do? \u00b6 This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments. Installation \u00b6 You can install this package via pip; pip install memo You might want to install extra dependencies depending on your usecase. pip install \"memo[httpx]\" pip install \"memo[wandb]\"","title":"Home"},{"location":"index.html#what-does-this-package-do","text":"This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments.","title":"What does this package do?"},{"location":"index.html#installation","text":"You can install this package via pip; pip install memo You might want to install extra dependencies depending on your usecase. pip install \"memo[httpx]\" pip install \"memo[wandb]\"","title":"Installation"},{"location":"api.html","text":"from memo import memlist \u00b6 memlist ( data ) \u00b6 Remembers input/output of a function in python list. Parameters: Name Type Description Default data a list to push received data into required Example from meme import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): data . append ( simulate ( a = a , b = b ) assert len ( data ) == 50 Source code in memo/_base.py def memlist ( data ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from meme import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): data.append(simulate(a=a, b=b) assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator memfile ( filepath ) \u00b6 Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath path to write data to required Source code in memo/_base.py def memfile ( filepath ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : f . write ( json . dumps ({ ** kwargs , ** result }) + \" \\n \" ) return result return wrapper return decorator memstdout ( print_fn =< built - in function print > ) \u00b6 Remembers input/output of a function by printing. Parameters: Name Type Description Default print_fn option to overwrite the print_fn that is used, this allows you to attach a logger instead <built-in function print> Source code in memo/_base.py def memstdout ( print_fn = print ): \"\"\" Remembers input/output of a function by printing. Arguments: print_fn: option to overwrite the print_fn that is used, this allows you to attach a logger instead \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) print_fn ({ ** kwargs , ** result }) return result return wrapper return decorator memweb ( url ) \u00b6 Remembers input/output of a function by sending it over http to an endpoint. Parameters: Name Type Description Default filepath path to write data to required Source code in memo/_http.py def memweb ( url ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Arguments: filepath: path to write data to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator memwandb ( project , ** config ) \u00b6 Remembers input/output of a function by sending it to wandb. Parameters: Name Type Description Default project name of the wandb project you want to send to required config optional extra keyword arguments to send along {} Usage: import os # You probably want to run with this setting to prevent a # whole lot of output suddenly appearing. os . environ [ \"WANDB_SILENT\" ] = \"true\" Source code in memo/_wandb.py def memwandb ( project , ** config ): \"\"\" Remembers input/output of a function by sending it to wandb. Arguments: project: name of the wandb project you want to send to config: optional extra keyword arguments to send along Usage: ```python import os # You probably want to run with this setting to prevent a # whole lot of output suddenly appearing. os.environ[\"WANDB_SILENT\"] = \"true\" ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): import logging logger = logging . getLogger ( \"wandb\" ) logger . setLevel ( logging . ERROR ) wandb . init ( project = project ) wandb . config = config result = func ( * args , ** kwargs ) wandb . log ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"Base"},{"location":"api.html#from-memo-import-memlist","text":"","title":"from memo import memlist"},{"location":"api.html#memo._base.memlist","text":"Remembers input/output of a function in python list. Parameters: Name Type Description Default data a list to push received data into required Example from meme import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): data . append ( simulate ( a = a , b = b ) assert len ( data ) == 50 Source code in memo/_base.py def memlist ( data ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from meme import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): data.append(simulate(a=a, b=b) assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memlist()"},{"location":"api.html#memo._base.memfile","text":"Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath path to write data to required Source code in memo/_base.py def memfile ( filepath ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : f . write ( json . dumps ({ ** kwargs , ** result }) + \" \\n \" ) return result return wrapper return decorator","title":"memfile()"},{"location":"api.html#memo._base.memstdout","text":"Remembers input/output of a function by printing. Parameters: Name Type Description Default print_fn option to overwrite the print_fn that is used, this allows you to attach a logger instead <built-in function print> Source code in memo/_base.py def memstdout ( print_fn = print ): \"\"\" Remembers input/output of a function by printing. Arguments: print_fn: option to overwrite the print_fn that is used, this allows you to attach a logger instead \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) print_fn ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memstdout()"},{"location":"api.html#memo._http.memweb","text":"Remembers input/output of a function by sending it over http to an endpoint. Parameters: Name Type Description Default filepath path to write data to required Source code in memo/_http.py def memweb ( url ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Arguments: filepath: path to write data to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator","title":"memweb()"},{"location":"api.html#memo._wandb.memwandb","text":"Remembers input/output of a function by sending it to wandb. Parameters: Name Type Description Default project name of the wandb project you want to send to required config optional extra keyword arguments to send along {} Usage: import os # You probably want to run with this setting to prevent a # whole lot of output suddenly appearing. os . environ [ \"WANDB_SILENT\" ] = \"true\" Source code in memo/_wandb.py def memwandb ( project , ** config ): \"\"\" Remembers input/output of a function by sending it to wandb. Arguments: project: name of the wandb project you want to send to config: optional extra keyword arguments to send along Usage: ```python import os # You probably want to run with this setting to prevent a # whole lot of output suddenly appearing. os.environ[\"WANDB_SILENT\"] = \"true\" ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): import logging logger = logging . getLogger ( \"wandb\" ) logger . setLevel ( logging . ERROR ) wandb . init ( project = project ) wandb . config = config result = func ( * args , ** kwargs ) wandb . log ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memwandb()"},{"location":"faq.html","text":"Can I add a progress bar? \u00b6 We don't offer a progress bar natively in this library, but nothing is stopping you from using rich or tqdm for this. Rich Demo \u00b6 import numpy as np from rich.progress import Progress from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = list ( grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ])) with Progress () as progress : task = progress . add_task ( \"[green]Processing...\" , total = len ( settings )) for setting in settings : birthday_experiment ( ** setting ) progress . update ( task , advance = 1 ) Tqdm Demo \u00b6 import numpy as np import tqdm from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = list ( grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ])) for setting in tqdm . tqdm ( settings ): birthday_experiment ( ** setting )","title":"FAQ"},{"location":"faq.html#can-i-add-a-progress-bar","text":"We don't offer a progress bar natively in this library, but nothing is stopping you from using rich or tqdm for this.","title":"Can I add a progress bar?"},{"location":"faq.html#rich-demo","text":"import numpy as np from rich.progress import Progress from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = list ( grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ])) with Progress () as progress : task = progress . add_task ( \"[green]Processing...\" , total = len ( settings )) for setting in settings : birthday_experiment ( ** setting ) progress . update ( task , advance = 1 )","title":"Rich Demo"},{"location":"faq.html#tqdm-demo","text":"import numpy as np import tqdm from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = list ( grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ])) for setting in tqdm . tqdm ( settings ): birthday_experiment ( ** setting )","title":"Tqdm Demo"},{"location":"getting-started.html","text":"Base Scenario \u00b6 Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation. Decorators \u00b6 The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) . Logging More \u00b6 The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Power \u00b6 The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Utilities \u00b6 The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings ) More features \u00b6 These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. @memfunc allows you to attach a callback, like print @memweb allows you to post the data via http to a webserver @memwand allows you to post results to weights and biases . grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments","title":"Getting Started"},{"location":"getting-started.html#base-scenario","text":"Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation.","title":"Base Scenario"},{"location":"getting-started.html#decorators","text":"The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) .","title":"Decorators"},{"location":"getting-started.html#logging-more","text":"The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Logging More"},{"location":"getting-started.html#power","text":"The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Power"},{"location":"getting-started.html#utilities","text":"The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , capture_time data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @capture_time ( time_taken = True ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings )","title":"Utilities"},{"location":"getting-started.html#more-features","text":"These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. @memfunc allows you to attach a callback, like print @memweb allows you to post the data via http to a webserver @memwand allows you to post results to weights and biases . grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments","title":"More features"},{"location":"util.html","text":"from memo import memlist \u00b6 grid ( ** kwargs ) \u00b6 Source code in memo/_grid.py def grid ( ** kwargs ): for c in it . product ( * [ v for v in kwargs . values ()]): yield { k : v for k , v in zip ( kwargs . keys (), c )} random_grid ( n = 30 , ** kwargs ) \u00b6 Source code in memo/_grid.py def random_grid ( n = 30 , ** kwargs ): for i in range ( n ): yield { k : random . choice ( v ) for k , v in kwargs . items ()}","title":"Utility"},{"location":"util.html#from-memo-import-memlist","text":"","title":"from memo import memlist"},{"location":"util.html#memo._grid.grid","text":"Source code in memo/_grid.py def grid ( ** kwargs ): for c in it . product ( * [ v for v in kwargs . values ()]): yield { k : v for k , v in zip ( kwargs . keys (), c )}","title":"grid()"},{"location":"util.html#memo._grid.random_grid","text":"Source code in memo/_grid.py def random_grid ( n = 30 , ** kwargs ): for i in range ( n ): yield { k : random . choice ( v ) for k , v in kwargs . items ()}","title":"random_grid()"}]}